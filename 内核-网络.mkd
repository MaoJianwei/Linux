struct socket{
    socket_state            state;  //套接字连接状态
    const struct proto_ops  *ops;
    struct file             *file;  //指向伪文件的file实例
    struct sock             *sk;
    short                   type;   //指定所用协议的数字标识符
};

typedef enum{
    SS_FREE = 0;        //未分配
    SS_UNCONNECTED,     //未连接到任何套接字
    SS_CONNECTING,      //处于连接过程中
    SS_CONNECTED        //已经连接到另一个套接字
    SS_DISCONNECTING,   //处于断开连接过程中
} socket_state;


/* C库函数会通过socketcall系统调用下列的函数指针，socket结构的ops成员所包含的函数指针用于和系统调用通信*/
struct proto_ops{
    int             family;
    struct module   *owner;
    int             (*release);
    int             (*bind);

    int             (*connect);

    int             (*socketpair);

    int             (*accept);
    int             (*getname);

    unsigned int    (*poll);
    int             (*ioctl);
    int             (*compat_ioctl);
    int             (*listen);
    int             (*shutdown);
    int             (*setsockopt)
    int             (*getsockopt)
    int             (*compat_setsockopt)
    int             (*compat_getsockopt)
    int             (*sendmsg)
    int             (*recvmsg)
    int             (*mmap)
    ssize_t         (*sendpage)
}

/* struct socket的ops成员类型是struct proto_ops,与之相似的一个结构是struct proto,sock的port成员类型是struct proto，
 * 里面的成员函数主要用于（内核端）套接字层和传输层之间的通信。
 */
include/net/sock.h
struct proto{
    void            (*close)(struct sock*sk,
                            long timeout);
    int             (*connect)(struct sock *sk,
                            struct sockaddr *uaddr,
                            int addr_len);
    int             (*disconnect)(struct sock *sk, int flags);
    struct sock*    (*accept)(struct sock*sk, int flags, int *err);
}

/* 内核将自身最重要的一些成员放到sock_common结构中 */
include/net/sock.h

struct sock_common{
    unsigned short          skc_family;
    volatile unsigned char  skc_state;
    struct hlist_node       skc_node;
    unsigned int            skc_hash;
    atomic_t                skc_refcnt;
    struct proto            *skc_prot;
};
/* 并将sock_common嵌入在struct sock开始处*/
struct sock{
    struct sock_common      __sk_common;
    struct sk_buff_head     sk_receive_queue;
    struct sk_buff_head     sk_write_queue;
    struct timer_list       sk_timer;
    void                    (*sk_date_ready) (struct sock *sk, int bytes);
    ...
}

/*
 * 套接字和文件
 * 每个套接字都被分配了一个该类型的inode，inode又关联到另一个普通文件相关的结构。
 * 因而，对套接字文件描述符的操作，可以透明的重定向到网络子系统的代码。
 * 套接字使用的file_operations如下：
 */

 net/socket.c

 struct file_operations socket_file_ops = {
    .owner =                THIS_MODULE,
    .llseek =               no_llseek,
    .aio_read =             sock_aio_read,
    .aio_write =            sock_aio_write,
    .poll =                 sock_poll,
    .unlocked_ioctl =       sock_ioctl,
    .compat_ioctl =         compat_sock_ioctl,
    .mmap =                 sock_mmap,
    .open =                 sock_no_open,
    .release =              sock_close,
    .fasync =               sock_fasync,
    .sendpage =             sock_sendapge,
    .splice_write =         generic_splice_sendpage,
 };

 /* socketcall系统调用
  * 17个套接字操作只对应一个系统调用，由于要处理任务不同，参数列表可能差别很大
  * 该系统调用的第一个参数与时一个数值常数，选择所需要的系统调用。
  * 可能的值包括SYS_SOCKET，SYS_BIND，SYS_ACCEPT和SYS_RECV。
  */
net/socket.c

asmlinkage long sys_socketcall(int call, unsigned long __user * args){
    unsigned long a[6];
    unsigned long a0, a1;
    int err;

    if(call<1 || call>SYS_RECVMSG)
        return -EINVAL;
}

sys_socket时创建新套接字的起点。首先使用socket_create创建一个新的套接字数据结构，该函数直接调用了__sock_create。
分配内存的任务委托给sock_alloc，该函数不仅为struct socket实例分配了空间，还紧接着该实例为inode分配了内存空间。

内核的所有传输协议都群集在net/socket.c中定义的数组static struct net_proto_family * net_families[NPROTO]中
（sock_register用于向该数据库增加新的数据项）。各个数组项都提供了特定于协议的初始化函数。

net.h
struct net_proto_family{
    int             family;
    int             (*create)(struct socket*sock, int protocol);
    struct module   *owner;
}

在为套接字分配了内存之后，刚好调用函数create。inet_create用于因特网连接（TCP和UDP都使用该函数）。
map_sock_fd为套接字创建一个伪文件（文件通过socket_ops指定）。还要分配一个文件描述符，将其作为系统调用的结果返回。