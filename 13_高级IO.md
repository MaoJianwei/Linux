# 13 高级I/O

## 13.1 引言

本章涵盖众多概念和函数，我们把它们统统放在高级I/O下讨论，非阻塞I/O、记录锁、I/O多路转接（select和poll函数）、异步I/O、readv和writev函数以及储存映射（mmap）。第15章和第17章中的进程间通信以及以后各章中的很多实例都要使用本章所描述的概念和函数。

## 13.2 非阻塞I/O

系统调用可以分为两类：“低速”系统调用和其他。低速系统调用时可能会使进程永远阻塞的一类系统调用，包括：
* 如果某些文件类型（如读管道、终端设备和网络设备）的数据不存在，读操作可能会使调用者永远阻塞；
* 如果数据不能被相同的文件类型立即接受（如管道中无空间、网络流控制），写操作可能会使调用者永远阻塞；
* 在某些条件发生前打开某些文件类型可能发生阻塞（如要打开一个终端设备，需要先等待与之连接的调制解调器应答，又如若以只写模式打开FIFO，那么在没有其他进程已用读模式打开该FIFO时也要等待）；
* 对已经加上强制性记录锁的文件进行读写；
* 某些ioctl操作；
* 某些进程间通信函数。

我们也曾说过，虽然读写磁盘文件会暂时阻塞调用者，但是并不能将与裁判I/O有干的系统调用视为“低速”。

非阻塞I/O使我们可以发出open、read和write这样的I/O操作，并是这些操作不会永远阻塞。如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞。

对于一个给定的描述符，有两种为其制定非阻塞I/O的方法。

1. 如果调用open获得描述符，则可制定O_NONBLOCK标志。
2. 对于已经打开的描述符，泽科调用fcntl，由该函数打开O_NONBLOCK文件状态标志。

## 13.3 记录锁

当两个人同时编辑一个文件时，其后果将如何呢？在大多数UNIX系统中，该文件的最后状态取决于写该文件的最后一个进程。但是对于有些应用程序，如数据库，进程有时需要确保它正在单独写一个文件。为了向进程提供这种功能，商用UNIX系统提供记录锁机制。

记录锁的功能是：当第一个进程正在读或修改文件的某个部分时，使用估计卢梭可以阻止其它进程修改同一文件区。对于UNIX而言，“记录”这个词是一种误用，因为UNIX系统内核根本没有使用文件记录这种概念。一个更适合的术语可能是字节范围锁，因为它锁定的只是文件中的一个区域（也可能是整个文件）。

fcntl记录锁

在之前已经给出了fcntl的原型，这里再重复一次
```c
    #include <unistd.h>
    #include <fcntl.h>
    int fcntl(int fd, int cmd, ... /* arg */ );
```
对于记录锁，cmd是F_GETLK、F_SETLK或F_SETLKW。第三个参数（我们将调用flockptr）是一个指向flock结构的指针。
```c
    struct flock {
        ...
        short l_type;    /* Type of lock: F_RDLCK,
                            F_WRLCK, F_UNLCK */
        short l_whence;  /* How to interpret l_start:
                            SEEK_SET, SEEK_CUR, SEEK_END */
        off_t l_start;   /* Starting offset for lock */
        off_t l_len;     /* Number of bytes to lock */
        pid_t l_pid;     /* PID of process blocking our lock
                            (set by F_GETLK and F_OFD_GETLK) */
        ...
    };

```

上面提到了两种类型的锁：共享读锁和独占写锁。基本规则是：任意多个进程在一个给定的自己额上可以有一把共享的读锁，但是在一个给定字节上只能有一个进程有一把独占写锁。进一步而言，如果在一个给定字节上已经有一把或多把读锁，则不能再该字节上再加写锁；如果在一个字节上已经有一把独占写锁，则不能再对它加任何读锁。

如果两个进程都在等待对方持有并且不释放的资源时，则这两个进程处于死锁状态。如果一个进程已经控制了文件中的一个加锁区域，然后它有试图对另一个进程控制的区域加锁，那么他就会休眠，在这种情况下，有发生死锁的可能性。